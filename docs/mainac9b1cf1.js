!function(t){function e(e){for(var a,r,s=e[0],d=e[1],l=e[2],c=0,u=[];c<s.length;c++)r=s[c],o[r]&&u.push(o[r][0]),o[r]=0;for(a in d)Object.prototype.hasOwnProperty.call(d,a)&&(t[a]=d[a]);for(p&&p(e);u.length;)u.shift()();return i.push.apply(i,l||[]),n()}function n(){for(var t,e=0;e<i.length;e++){for(var n=i[e],a=!0,s=1;s<n.length;s++){var d=n[s];0!==o[d]&&(a=!1)}a&&(i.splice(e--,1),t=r(r.s=n[0]))}return t}var a={},o={0:0},i=[];function r(e){if(a[e])return a[e].exports;var n=a[e]={i:e,l:!1,exports:{}};return t[e].call(n.exports,n,n.exports,r),n.l=!0,n.exports}r.m=t,r.c=a,r.d=function(t,e,n){r.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n})},r.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},r.t=function(t,e){if(1&e&&(t=r(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var a in t)r.d(n,a,function(e){return t[e]}.bind(null,a));return n},r.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(e,"a",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p="";var s=window.webpackJsonp=window.webpackJsonp||[],d=s.push.bind(s);s.push=e,s=s.slice();for(var l=0;l<s.length;l++)e(s[l]);var p=d;i.push([159,1]),n()}({129:function(t,e,n){t.exports=n.p+"data/data65a5c920.csv"},130:function(t){t.exports={hello:"json"}},131:function(t,e,n){t.exports=n.p+"data/datac897d141.txt"},132:function(t,e,n){t.exports=n.p+"images/frame1a76e2091.png"},133:function(t,e,n){t.exports=n.p+"images/frame27665ea55.png"},134:function(t,e,n){t.exports=n.p+"images/frame3ebba0b1a.png"},135:function(t,e,n){t.exports=n.p+"images/frame4d219b06c.png"},136:function(t,e,n){t.exports=n.p+"images/frame570a1bad3.png"},137:function(t,e,n){t.exports=n.p+"images/frame69e8799bf.png"},138:function(t,e,n){t.exports=n.p+"images/frame700a89b60.png"},139:function(t,e,n){t.exports=n.p+"images/frame89f8dcdcf.png"},140:function(t,e,n){t.exports=n.p+"images/frame919f6a008.png"},141:function(t,e,n){t.exports=n.p+"images/frame101c46bd08.png"},142:function(t,e,n){t.exports=n.p+"images/frame1129ce356f.png"},143:function(t,e,n){t.exports=n.p+"images/frame122b61781c.png"},144:function(t,e,n){t.exports=n.p+"images/frame13c9b505fc.png"},145:function(t,e,n){t.exports=n.p+"images/frame14371d5c79.png"},146:function(t,e,n){t.exports=n.p+"images/jupiterxl0426baca.png"},147:function(t,e,n){t.exports=n.p+"images/jupiterxl_bump80afc05d.png"},148:function(t,e,n){t.exports=n.p+"images/jupiterxl_specfe5f3263.png"},149:function(t,e,n){t.exports=n.p+"images/iodc488f17.jpg"},150:function(t,e,n){t.exports=n.p+"images/europa58a6f51f.jpg"},151:function(t,e,n){t.exports=n.p+"images/europa_bump9d2c57f1.jpg"},152:function(t,e,n){t.exports=n.p+"images/ganymedeff75bee1.jpg"},153:function(t,e,n){t.exports=n.p+"images/ganymede_bumpa28f7117.jpg"},154:function(t,e,n){t.exports=n.p+"images/callisto16b2c8ac.png"},155:function(t,e,n){t.exports=n.p+"images/callisto_bumpe0c02a24.png"},156:function(t,e,n){t.exports=n.p+"images/lensflare028ecca63.png"},157:function(t,e,n){t.exports=n.p+"images/lensflare2317811aa.png"},158:function(t,e,n){t.exports=n.p+"images/lensflare320a2bd3c.png"},159:function(t,e,n){n(160),t.exports=n(362)},362:function(t,e,n){"use strict";n.r(e);n(363),n(368)},363:function(t,e,n){var a=n(364);"string"==typeof a&&(a=[[t.i,a,""]]);var o={hmr:!0,transform:void 0,insertInto:void 0};n(366)(a,o);a.locals&&(t.exports=a.locals)},364:function(t,e,n){(t.exports=n(365)(!1)).push([t.i,"html, body {\n  height: 100%;\n  background-color: black;\n  margin: 0;\n  padding: 0;\n  overflow: hidden;\n  overscroll-behavior: none; }\n",""])},368:function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var a=n(383);document.onreadystatechange=function(){var t=document.readyState;"interactive"===t?document.getElementById("contents").style.visibility="hidden":"complete"===t&&(document.getElementById("interactive"),document.getElementById("loader").style.visibility="hidden",document.getElementById("contents").style.visibility="visible",a.default.init())},window.addEventListener("resize",a.default.onResize)},383:function(t,e,n){"use strict";n.r(e);var a=n(32);window.THREE=a,n(369),n(370),n(371),n(372),n(373),n(374),n(375),n(376),n(377),n(378),n(379),n(380),n(381),n(382);var o=a,i=n(128),r=n(65),s=n(66),d=n(32),l=n(129),p=n(130),c=n.t(p,2),u=n(131),f=n(132),m=n(133),h=n(134),g=n(135),v=n(136),w=n(137),x=n(138),S=n(139),y=n(140),M=n(141),b=n(142),C=n(143),T=n(144),E=n(145),D=n(146),P=n(147),L=n(148),z=n(149),_=n(150),I=n(151),N=n(152),H=n(153),R=n(154),U=n(155),O=n(156),B=n(157),G=n(158),F={csvFile:l,jsonFile:c,txtFile:u,fragmentShader:s,vertexShader:r,jupiter:{frames:[f,m,h,g,v,w,x,S,y,M,b,C,T,E]},jupiterxl:D,jupiterxlbump:P,jupiterxlspec:L,io:z,europa:_,europabump:I,ganymede:N,ganymedebump:H,callisto:R,callistobump:U,lensFlare:{textureFlare0:O,textureFlare1:B,textureFlare2:G}};function j(t,e,n){return function(a){t[e]=n[a],t.needsUpdate=!0}}function k(t,e){return function(){t.shading=+t.shading,t.vertexColors=+t.vertexColors,t.side=+t.side,t.needsUpdate=!0,e.verticesNeedUpdate=!0,e.normalsNeedUpdate=!0,e.colorsNeedUpdate=!0}}function A(t,e){return d.ShaderChunk[e]+"\n"}function V(t){return t.replace(/\/\/\s?chunk\(\s?(\w+)\s?\);/g,A)}var W=function(t,e){var n=e.geometry,a=e.material,o=e.castShadow,i=e.receiveShadow,r=e.orbit,s=new d.Mesh(n,a);return s.name=t,s.castShadow=o,s.receiveShadow=i,function(t){return t.add(s),t.add(r),s}},Z=function(t,e){var n=e.scale;return n&&t.applyMatrix(n),t};var Y,K,X,q,J,Q,$,tt,et,nt,at,ot,it,rt,st,dt,lt,pt,ct,ut,ft,mt,ht,gt,vt,wt={blendingMode:{"THREE.NoBlending":o.NoBlending,"THREE.NormalBlending":o.NormalBlending,"THREE.AdditiveBlending":o.AdditiveBlending,"THREE.SubtractiveBlending":o.SubtractiveBlending,"THREE.MultiplyBlending":o.MultiplyBlending,"THREE.CustomBlending":o.CustomBlending},combine:{"THREE.MultiplyOperation":o.MultiplyOperation,"THREE.MixOperation":o.MixOperation,"THREE.AddOperation":o.AddOperation},side:{"THREE.FrontSide":o.FrontSide,"THREE.BackSide":o.BackSide,"THREE.DoubleSide":o.DoubleSide},colors:{"THREE.NoColors":o.NoColors,"THREE.FaceColors":o.FaceColors,"THREE.VertexColors":o.VertexColors},SCREEN_HEIGHT:window.innerHeight-200,SCREEN_WIDTH:window.innerWidth},xt=0,St=0,yt=function(){for(var t=new d.TextureLoader,e=[],n=0;n<14;n++)e[n]=t.load(F.jupiter.frames[n]);var a={none:null,tx:t.load(F.jupiterxl),txframe:e[0],txbump:t.load(F.jupiterxlbump),txspecular:t.load(F.jupiterxlspec),io:t.load(F.io),europa:t.load(F.europa),europabump:t.load(F.europabump),ganymede:t.load(F.ganymede),ganymedebump:t.load(F.ganymedebump),callisto:t.load(F.callisto),callistobump:t.load(F.callistobump)},o=t.load(F.lensFlare.textureFlare0),i=t.load(F.lensFlare.textureFlare1),r=t.load(F.lensFlare.textureFlare2);return{textureMaps:a,textureMapKeys:Object.keys(a),flares:[o,i,r],frames:e}}(),Mt=(ht={textureMapKeys:yt.textureMapKeys,props:wt},gt=ht.textureMapKeys,vt=ht.props,{timestep:1e3,backgroundColor:"#000000",ambientColor:"#000000",antialias:!0,helpers:!1,axes:!1,fogDensity:0,fov:45,focalLength:200,filmGauge:1,focus:1,hBlurEnabled:!1,vBlurEnabled:!1,hBlurLevel:window.innerWidth,vBlurLevel:window.innerHeight,bloomEnabled:!1,exposure:1,bloomStrength:1.5,bloomThreshold:.1,bloomRadius:.8,filmEnabled:!0,filmTime:0,filmGrayscale:!1,filmSCount:2*vt.SCREEN_HEIGHT,filmSIntensity:.42,filmNIntensity:.24,ccEnabled:!0,ccPowerFactor:1.58,anisotropy:1,magFilter:d.NearestFilter,minFilter:d.NearestFilter,rotationY:1/35730,cloudspeed:.01,staticMix:1,transparent:!1,opacity:1,alphaTest:0,flatShading:!1,blending:d.AdditiveBlending,depthTest:!0,depthWrite:!0,side:vt.side,wireframe:!1,wireframeLinewidth:1,animated:!0,map:gt,lightMap:gt,normalMap:gt,normalScale:0,alphaMap:gt,specularMap:gt,specular:"#252525",shininess:0,aoMap:gt,aoMapIntensity:0,bumpMap:gt,bumpScale:0,emissiveMap:gt,emissiveColor:"#00ff00",emissiveIntensity:0,displacementMap:gt,displacementScale:0,sunpositionX:1,sunpositionY:0,sunpositionZ:100,sunlightVisible:!0,sunlightColor:"#ffffff",sunlightIntensity:.9,castShadow:!0});var bt=function(){if(Mt.animated){var t=ft.uniforms.mixRatio.value;(t+=Mt.cloudspeed)>1&&(St>12&&(St=0),ft.uniforms.tDiffuse1.value=yt.frames[St],ft.uniforms.tDiffuse2.value=yt.frames[++St],t=0),ft.uniforms.mixRatio.value=t,$.material.needsUpdate=!0}};function Ct(){q.render();var t=Q.getDelta();xt+=t*Mt.timestep,bt(),pt.uniforms.time.value=Math.random(),$.rotation.y+=2*Math.PI*t*Mt.timestep*293e-8;var e=2*Math.PI*6542e-9*xt;tt.position.x=5.874783193*Math.cos(e),tt.position.z=-5.922340961*Math.sin(e),et.position.x=9.298942539*Math.cos(.498182999*e),et.position.z=-9.475186035*Math.sin(.498182999*e),nt.position.x=14.955519499*Math.cos(.247274428*e),nt.position.z=-14.989089688*Math.sin(.247274428*e),at.position.x=26.142785207*Math.cos(.106006117*e),at.position.z=-26.53443742*Math.sin(.106006117*e),J.update(),requestAnimationFrame(Ct)}function Tt(t,e,n,a){var i=new o.EllipseCurve(0,0,e,n,0,2*Math.PI,!1),r=(new o.Geometry).setFromPoints(i.getPoints(512)),s=new o.LineBasicMaterial({fog:!0,color:5526612}),d=new o.Line(r,s);return d.rotation.x=Math.PI/2,d.rotation.z=a/180*Math.PI,d.name=t,d.visible=Mt.helpers,d}function Et(){q=new o.EffectComposer(Y),rt.setSize=function(){},q.addPass(rt),Mt.hBlurEnabled&&q.addPass(dt),Mt.vBlurEnabled&&q.addPass(lt),Mt.filmEnabled&&q.addPass(pt),Mt.bloomEnabled&&q.addPass(ut),Mt.ccEnabled&&q.addPass(ct),q.addPass(st),st.renderToScreen=!0}window.document.onkeydown=function(t){83===t.keyCode&&((void 0).domElement.style.zIndex*=-1)};e.default={init:function(){(Y=new o.WebGLRenderer({antialias:Mt.antialias,alpha:!0})).setSize(wt.SCREEN_WIDTH,wt.SCREEN_HEIGHT),Y.setClearColor(Mt.backgroundColor),Y.shadowMap.enabled=!0,Y.shadowMap.type=o.PCFSoftShadowMap,Y.domElement.style.top="100px",Y.domElement.style.position="absolute",Y.domElement.style.backgroundColor="#000",document.getElementById("contents").appendChild(Y.domElement),(X=new o.PerspectiveCamera(45,wt.SCREEN_WIDTH/wt.SCREEN_HEIGHT,.001,15e5)).position.set(0,0,100),X.setFocalLength(Mt.focalLength),(K=new o.Scene).fog=new o.FogExp2(Mt.backgroundColor,Mt.fogDensity),J=new o.OrbitControls(X,Y.domElement),Q=new o.Clock,(ft=new o.ShaderMaterial({defines:{},uniforms:o.UniformsUtils.merge([o.UniformsLib.lights,o.UniformsLib.shadowmap,{tDiffuse1:{type:"t",value:null},tDiffuse2:{type:"t",value:null},tDiffuse3:{type:"t",value:null},mixRatio:{type:"f",value:.5},staticRatio:{type:"f",value:.5},opacity:{type:"f",value:Mt.opacity}}]),vertexShader:V(r),fragmentShader:V(s)})).uniforms.tDiffuse1.value=yt.frames[St],ft.uniforms.tDiffuse2.value=yt.frames[St+1],ft.uniforms.tDiffuse3.value=yt.textureMaps.tx,ft.uniforms.mixRatio.value=Mt.cloudspeed,ft.uniforms.staticRatio.value=Mt.staticMix,ft.lights=!0,mt=new o.MeshPhongMaterial({visible:!0,transparent:Mt.transparent,opacity:Mt.opacity,alphaTest:Mt.alphaTest,depthTest:Mt.depthTest,depthWrite:Mt.depthWrite,side:Mt.side,blending:o.AdditiveBlending,flatShading:Mt.flatShading,map:yt.textureMaps.none,aoMap:yt.textureMaps.none,aoMapIntensity:Mt.aoMapIntensity,normalMap:yt.textureMaps.none,normalScale:Mt.normalScale,lightMap:yt.textureMaps.none,alphaMap:yt.textureMaps.none,emissiveMap:yt.textureMaps.none,emissive:Mt.emissiveColor,emissiveIntensity:Mt.emissiveIntensity,specularMap:yt.textureMaps.none,specular:Mt.specular,shininess:Mt.shininess,displacementMap:yt.textureMaps.none,displacementScale:Mt.displacementScale,bumpMap:yt.textureMaps.none,bumpScale:Mt.bumpScale,wireframe:Mt.wireframe,wireframeLinewidth:Mt.wireframeLinewidth});var t=Z(new o.SphereGeometry(1,128,128),{scale:(new o.Matrix4).makeScale(1.064874392,1,1.064874392)});($=new o.Mesh(t,ft)).rotation.x=3.13/180*Math.PI,$.receiveShadow=!0,$.castShadow=!1,X.lookAt($),K.add($),tt=W("io",{geometry:Z(new o.SphereGeometry(.027247435,128,128),{scale:(new o.Matrix4).makeScale(1.0061748634,1,.9981270313)}),material:new o.MeshPhongMaterial({map:yt.textureMaps.io,shininess:0,bumpMap:yt.textureMaps.iobump}),castShadow:!0,receiveShadow:!0,orbit:Tt("ioOrbit",5.874783193,5.922340961,.05)})(K),et=W("europa",{geometry:new o.SphereGeometry(.023346397,128,128),material:new o.MeshPhongMaterial({map:yt.textureMaps.europa,bumpMap:yt.textureMaps.europabump,bumpScale:1e-4,specularMap:yt.textureMaps.europabump,specular:new o.Color("#f0f7ff"),shininess:1}),castShadow:!0,receiveShadow:!0,orbit:Tt("euOrbit",9.298942539,9.475186035,.47)})(K),nt=W("ganymede",{geometry:new o.SphereGeometry(.039357406,128,128),material:new o.MeshPhongMaterial({map:yt.textureMaps.ganymede,bumpMap:yt.textureMaps.ganymedebump,bumpScale:.001,shininess:0}),castShadow:!0,receiveShadow:!0,orbit:Tt("gmOrbit",14.955519499,14.989089688,.21)})(K),at=W("callisto",{geometry:new o.SphereGeometry(.036053191,128,128),material:new o.MeshPhongMaterial({map:yt.textureMaps.callisto,shininess:0}),castShadow:!0,receiveShadow:!0,orbit:Tt("caOrbit",26.142785207,26.53443742,.51)})(K),function(t,e,n,a,i,r){(ot=new o.PointLight(16777215,1.5)).color.setHSL(t,e,n),ot.position.set(a,i,r),ot.castShadow=!0,ot.shadowMapEnabled=!0,ot.shadow.mapSize.height=1024,ot.shadow.mapSize.width=1024,ot.shadow.camera.near=.001,ot.shadow.camera.far=15e4,ot.lookAt($),ot.name="sunlight",K.add(ot);var s=new o.Color(16777215);s.setHSL(t,e,n+.5);var d=new o.Lensflare;d.addElement(new o.LensflareElement(yt.flares[0],256,0,s,o.AdditiveBlending)),d.addElement(new o.LensflareElement(yt.flares[1],3,0,s,o.AdditiveBlending)),d.addElement(new o.LensflareElement(yt.flares[2],60,.6,s,o.AdditiveBlending)),d.addElement(new o.LensflareElement(yt.flares[2],70,.7,s,o.AdditiveBlending)),d.addElement(new o.LensflareElement(yt.flares[2],120,.9,s,o.AdditiveBlending)),d.addElement(new o.LensflareElement(yt.flares[2],70,1,s,o.AdditiveBlending)),d.customUpdateCallback=function(t){var e,n,a=t.lensFlares.length,i=2*-t.positionScreen.x,r=2*-t.positionScreen.y;for(e=0;e<a;e++)(n=t.lensFlares[e]).x=t.positionScreen.x+i*n.distance,n.y=t.positionScreen.y+r*n.distance,n.rotation=0;t.lensFlares[1].y+=.025,t.lensFlares[2].rotation=.5*t.positionScreen.x+o.Math.degToRad(45)},d.position.copy(ot.position),d.name="sunflare",K.add(d)}(.995,.5,.9,0,0,643.462171299);var e=new o.AmbientLight(new o.Color("#000000"));e.name="ambientLight",K.add(e),(it=new o.AxesHelper(30)).visible=Mt.axes,K.add(it),function(){for(var t=new o.Geometry,e=0;e<1e5;e++){var n=2*Math.random()-1,a=2*Math.random()-1,i=2*Math.random()-1,r=new o.Vector3(n,a,i);r.normalize(),r.multiplyScalar(15e4),t.vertices.push(r);var s=Math.random();t.colors.push(new o.Color(s/1.2,s/1.05,s))}var d=new o.PointsMaterial({size:500+500*Math.random(),vertexColors:o.VertexColors,blending:o.AdditiveBlending}),l=new o.Points(t,d);K.add(l)}(),rt=new o.RenderPass(K,X),(dt=new o.ShaderPass(o.HorizontalBlurShader)).uniforms.h.value=1/Mt.hBlurLevel,(lt=new o.ShaderPass(o.VerticalBlurShader)).uniforms.v.value=1/Mt.vBlurLevel,(pt=new o.ShaderPass(o.FilmShader)).uniforms.time.value=Mt.filmTime,pt.uniforms.grayscale.value=Mt.filmGrayscale,pt.uniforms.sCount.value=Mt.filmSCount,pt.uniforms.sIntensity.value=Mt.filmSIntensity,pt.uniforms.nIntensity.value=Mt.filmNIntensity,(ut=new o.UnrealBloomPass(new o.Vector2(wt.SCREEN_WIDTH,wt.SCREEN_HEIGHT),1.5,.4,.85)).renderToScreen=!0,ut.threshold=Mt.bloomThreshold,ut.strength=Mt.bloomStrength,ut.radius=Mt.bloomRadius,(ct=new o.ShaderPass(o.ColorCorrectionShader)).uniforms.powRGB.value=new o.Vector3(Mt.ccPowerFactor,Mt.ccPowerFactor,Mt.ccPowerFactor),(st=new o.ShaderPass(o.CopyShader)).renderToScreen=!0,Et(),function(){var t=new i.a;t.close();var e=t.addFolder("Camera");e.add(Mt,"fov",.1,180).step(.1).onChange(function(t){X.fov=t,X.updateProjectionMatrix()}),e.add(Mt,"focalLength",1,1200).step(1).onChange(function(t){X.setFocalLength(t),X.updateProjectionMatrix()});var n=t.addFolder("Scene");n.add(Mt,"timestep",-1e4,1e4).step(100),n.addColor(Mt,"backgroundColor").onChange(function(t){Y.setClearColor(new o.Color(t)),K.fog.color=new o.Color(t)}),n.addColor(Mt,"ambientColor").onChange(function(t){K.getObjectByName("ambientLight").color=new o.Color(t)}),n.add(Mt,"fogDensity",0,1).step(.01).onChange(function(t){K.fog.density=t}),n.add(Mt,"helpers").onChange(function(t){K.getObjectByName("ioOrbit").visible=t,K.getObjectByName("euOrbit").visible=t,K.getObjectByName("gmOrbit").visible=t,K.getObjectByName("caOrbit").visible=t}),n.add(Mt,"axes").onChange(function(t){it.visible=t});var a=t.addFolder("Postprocessing");a.add(Mt,"hBlurEnabled").onChange(Et),a.add(Mt,"vBlurEnabled").onChange(Et),a.add(Mt,"hBlurLevel",window.innerWidth,2.5*window.innerWidth).step(1).onChange(function(){dt.uniforms.h.value=1/Mt.hBlurLevel}),a.add(Mt,"vBlurLevel",window.innerHeight,2.5*window.innerHeight).step(1).onChange(function(){lt.uniforms.v.value=1/Mt.vBlurLevel}),a.add(Mt,"bloomEnabled").onChange(Et),a.add(Mt,"exposure",0,4).onChange(function(t){Y.toneMappingExposure=Math.pow(t,4)}),a.add(Mt,"bloomThreshold",0,5).onChange(function(t){ut.threshold=+t}),a.add(Mt,"bloomStrength",0,5).onChange(function(t){ut.strength=+t}),a.add(Mt,"bloomRadius",0,5).step(.05).onChange(function(t){ut.radius=+t}),a.add(Mt,"filmEnabled").onChange(Et),a.add(Mt,"filmTime",0,1).step(.01).onChange(function(){pt.uniforms.time.value=Mt.filmTime}),a.add(Mt,"filmGrayscale").onChange(function(){pt.uniforms.grayscale.value=Mt.filmGrayscale}),a.add(Mt,"filmSCount",512,8192).step(32).onChange(function(){pt.uniforms.sCount.value=Mt.filmSCount}),a.add(Mt,"filmSIntensity",0,1).step(.01).onChange(function(){pt.uniforms.sIntensity.value=Mt.filmSIntensity}),a.add(Mt,"filmNIntensity",0,1).step(.01).onChange(function(){pt.uniforms.nIntensity.value=Mt.filmNIntensity}),a.add(Mt,"ccEnabled").onChange(Et),a.add(Mt,"ccPowerFactor",1,3).step(.1).onChange(function(){ct.uniforms.powRGB.value.set(Mt.ccPowerFactor,Mt.ccPowerFactor,Mt.ccPowerFactor)});var r=t.addFolder("Jupiter Basic");r.add(Mt,"animated").onChange(function(){Mt.animated?($.material=ft,k($.material,$.geometry)):($.material=mt,k($.material,$.geometry))}),r.add(Mt,"cloudspeed",.001,.5).step(.002),r.add(Mt,"staticMix",0,1).step(.01).onChange(function(){ft.uniforms.staticRatio.value=Mt.staticMix}),r.add($.material,"transparent"),r.add(Mt,"opacity",0,1).onChange(function(){Mt.transparent&&(ft.uniforms.opacity.value=Mt.opacity,k($.material,$.geometry))}),r.add($.material,"alphaTest",0,1).step(1).onChange(k($.material,$.geometry)),r.add($.material,"depthTest"),r.add($.material,"depthWrite"),r.add($.material,"side",wt.side).onChange(k($.material,$.geometry)),r.add($.material,"flatShading",Mt.flatShading).onChange(k($.material,$.geometry));var s=t.addFolder("Jupiter Maps");s.add(Mt,"alphaMap",yt.textureMapKeys).onChange(j($.material,"alphaMap",yt.textureMaps)),s.add(Mt,"map",yt.textureMapKeys).onChange(j($.material,"map",yt.textureMaps)),s.add(Mt,"normalMap",yt.textureMapKeys).onChange(j($.material,"normalMap",yt.textureMaps)),s.add(Mt,"normalScale",0,5).step(.1).onChange(function(){$.material.normalScale=Mt.normalScale}),s.add(Mt,"lightMap",yt.textureMapKeys).onChange(j($.material,"lightMap",yt.textureMaps)),s.add(Mt,"aoMap",yt.textureMapKeys).onChange(j($.material,"aoMap",yt.textureMaps)),s.add(Mt,"aoMapIntensity",0,5).step(.2),s.add(Mt,"specularMap",yt.textureMapKeys).onChange(j($.material,"specularMap",yt.textureMaps)),s.addColor(Mt,"specular").onChange(function(t){$.material.specular=new o.Color(t)}),s.add(Mt,"shininess",0,100).step(.2).onChange(function(){$.material.shininess=Mt.shininess}),s.add(Mt,"emissiveMap",yt.textureMapKeys).onChange(j($.material,"emissiveMap",yt.textureMaps)),s.addColor(Mt,"emissiveColor").onChange(function(t){$.material.emissive=new o.Color(t)}),s.add(Mt,"emissiveIntensity",0,2).step(.05).onChange(function(){$.material.emissiveIntensity=Mt.emissiveIntensity}),s.add(Mt,"bumpMap",yt.textureMapKeys).onChange(j($.material,"bumpMap",yt.textureMaps)),s.add(Mt,"bumpScale",0,.05).step(1e-4).onChange(function(){$.material.bumpScale=Mt.bumpScale}),s.add(Mt,"displacementScale",0,.1).onChange(function(){$.material.displacementScale=Mt.displacementScale}),s.add(Mt,"displacementMap",yt.textureMapKeys).onChange(j($.material,"displacementMap",yt.textureMaps));var d=t.addFolder("Sunlight");d.add(Mt,"sunpositionX",-5e3,5e3).onChange(function(){var t=K.getObjectByName("sunlight"),e=K.getObjectByName("sunflare");t.position.x=Mt.sunpositionX,e.position.x=Mt.sunpositionX,t.lookAt($.position),$.material.needsUpdate=!0}),d.add(Mt,"sunpositionZ",-12e3,12e3).step(100).onChange(function(){var t=K.getObjectByName("sunlight"),e=K.getObjectByName("sunflare");t.position.z=Mt.sunpositionZ,e.position.z=Mt.sunpositionZ,t.lookAt($.position),$.material.needsUpdate=!0}),d.add(Mt,"sunpositionY",-500,500).onChange(function(){var t=K.getObjectByName("sunlight"),e=K.getObjectByName("sunflare");t.position.y=Mt.sunpositionY,e.position.y=Mt.sunpositionY,t.lookAt($.position),$.material.needsUpdate=!0}),d.add(Mt,"sunlightVisible").onChange(function(){var t=K.getObjectByName("sunlight");t.visible=Mt.sunlightVisible}),d.addColor(Mt,"sunlightColor").onChange(function(){var t=K.getObjectByName("sunlight");t.color=new o.Color(Mt.sunlightColor)}),d.add(Mt,"sunlightIntensity",0,5).onChange(function(){var t=K.getObjectByName("sunlight");t.intensity=Mt.sunlightIntensity}),d.add(Mt,"castShadow").onChange(function(){var t=K.getObjectByName("sunlight");t.castShadow=Mt.castShadow,$.material.needsUpdate=!0})}(),Q.start(),Ct()},onResize:function(){wt.SCREEN_WIDTH=window.innerWidth,wt.SCREEN_HEIGHT=window.innerHeight-200,X.aspect=wt.SCREEN_WIDTH/wt.SCREEN_HEIGHT,Y.setSize(wt.SCREEN_WIDTH,wt.SCREEN_HEIGHT),q.setSize(wt.SCREEN_WIDTH,wt.SCREEN_HEIGHT),X.updateProjectionMatrix()}}},65:function(t,e){t.exports="\n \t\t\tprecision highp float;\n\t\t\tprecision highp int;\n#define GLSLIFY 1\n\n\n\t\t\tvarying vec2 vUv;\n        \tvarying vec3 vPos;\n        \tvarying vec3 vNormal;\n\n    \t\t// shadowmap_pars_vertex\n    \t\t\t#ifdef USE_SHADOWMAP\n\n\t\t\t\t\t#if NUM_DIR_LIGHTS > 0\n\n\t\t\t\t\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\t\t\t\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if NUM_SPOT_LIGHTS > 0\n\n\t\t\t\t\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\t\t\t\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if NUM_POINT_LIGHTS > 0\n\n\t\t\t\t\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\t\t\t\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t    void main() {\n\n\t\t        // needed for shadowmap_vertex chunk\n\t\t        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t        vPos = worldPosition.xyz;\n\t\t        vNormal = normalMatrix * normal;\n\t\t        vUv = uv;\n\n\t\t        // shadowmap_vertex\n\t\t        \t#ifdef USE_SHADOWMAP\n\n\t\t\t\t\t\t#if NUM_DIR_LIGHTS > 0\n\n\t\t\t\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\t\t\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t#if NUM_SPOT_LIGHTS > 0\n\n\t\t\t\t\t\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\t\t\t\t\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t#if NUM_POINT_LIGHTS > 0\n\n\t\t\t\t\t\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\t\t\t\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#endif\n\n\t\t        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t        //gl_PointSize = 1.5;\n\t\t    }\n"},66:function(t,e){t.exports="#define GLSLIFY 1\n\t\t\tuniform vec3 ambientLightColor;\n\n\t\t\tstruct PointLight {\n\t\t\t\tvec3 color;\n\t\t\t\tvec3 position;\n\t\t\t\tfloat distance;\n\t\t\t\tfloat decay;\n\n\t\t\t\tint shadow;\n\t\t\t\tfloat shadowBias;\n\t\t\t\tfloat shadowRadius;\n\t\t\t\tvec2 shadowMapSize;\n\t\t\t};\n\n\t\t\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\n\t\t\tuniform float opacity;\n\t\t\tuniform float mixRatio;\n\t\t\tuniform float staticRatio;\n\t\t\tuniform sampler2D tDiffuse1;\n\t\t\tuniform sampler2D tDiffuse2;\n\t\t\tuniform sampler2D tDiffuse3;\n\n\t\t\tvarying vec3 vPos;\n\t\t\tvarying vec2 vUv;\n\t\t\tvarying vec3 vNormal;\n\n\t\t\t// packing\n\t\t \tvec3 packNormalToRGB( const in vec3 normal ) {\n\t\t\t  return normalize( normal ) * 0.5 + 0.5;\n\t\t\t}\n\n\t\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\t\t\t  return 1.0 - 2.0 * rgb.xyz;\n\t\t\t}\n\n\t\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\n\t\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\n\n\t\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\n\t\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n\n\t\t\tconst float ShiftRight8 = 1. / 256.;\n\n\t\t\tvec4 packDepthToRGBA( const in float v ) {\n\n\t\t\t\tvec4 r = vec4( fract( v * PackFactors ), v );\n\t\t\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\n\t\t\t\treturn r * PackUpscale;\n\n\t\t\t}\n\n\t\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\n\n\t\t\t\treturn dot( v, UnpackFactors );\n\n\t\t\t}\n\n\t\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\n\n\t\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\t\t\t  return ( viewZ + near ) / ( near - far );\n\t\t\t}\n\t\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\t\t\t  return linearClipZ * ( near - far ) - near;\n\t\t\t}\n\n\t\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\t\t\t  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n\t\t\t}\n\t\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\t\t\t  return ( near * far ) / ( ( far - near ) * invClipZ - far );\n\t\t\t}\n\t\t\t// shadowmap_pars_fragment\n\t\t\t#ifdef USE_SHADOWMAP\n\n\t\t\t\t#if NUM_DIR_LIGHTS > 0\n\n\t\t\t\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\t\t\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\n\t\t\t\t#endif\n\n\t\t\t\t#if NUM_SPOT_LIGHTS > 0\n\n\t\t\t\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\t\t\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\n\t\t\t\t#endif\n\n\t\t\t\t#if NUM_POINT_LIGHTS > 0\n\n\t\t\t\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\t\t\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\n\t\t\t\t#endif\n\n\t\t\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n\t\t\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\n\t\t\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\n\t\t\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\t\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\n\t\t\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\t\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\t\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\t\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\n\t\t\t\t\tvec2 f = fract( uv * size + 0.5 );\n\n\t\t\t\t\tfloat a = mix( lb, lt, f.y );\n\t\t\t\t\tfloat b = mix( rb, rt, f.y );\n\t\t\t\t\tfloat c = mix( a, b, f.x );\n\n\t\t\t\t\treturn c;\n\n\t\t\t\t}\n\n\t\t\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n\t\t\t\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\t\t\t\tshadowCoord.z += shadowBias;\n\n\t\t\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\n\t\t\t\t\t// if ( all( something, something ) ) using this instead\n\n\t\t\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\t\t\t\tbool inFrustum = all( inFrustumVec );\n\n\t\t\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n\t\t\t\t\tbool frustumTest = all( frustumTestVec );\n\n\t\t\t\t\tif ( frustumTest ) {\n\n\t\t\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\n\t\t\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n\t\t\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n\t\t\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t\t\t\t#else // no percentage-closer filtering:\n\n\t\t\t\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn 1.0;\n\n\t\t\t\t}\n\n\t\t\t\t// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n\t\t\t\t// vector suitable for 2D texture mapping. This code uses the following layout for the\n\t\t\t\t// 2D texture:\n\t\t\t\t//\n\t\t\t\t// xzXZ\n\t\t\t\t//  y Y\n\t\t\t\t//\n\t\t\t\t// Y - Positive y direction\n\t\t\t\t// y - Negative y direction\n\t\t\t\t// X - Positive x direction\n\t\t\t\t// x - Negative x direction\n\t\t\t\t// Z - Positive z direction\n\t\t\t\t// z - Negative z direction\n\t\t\t\t//\n\t\t\t\t// Source and test bed:\n\t\t\t\t// https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n\t\t\t\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n\t\t\t\t\t// Number of texels to avoid at the edge of each square\n\n\t\t\t\t\tvec3 absV = abs( v );\n\n\t\t\t\t\t// Intersect unit cube\n\n\t\t\t\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\t\t\t\tabsV *= scaleToCube;\n\n\t\t\t\t\t// Apply scale to avoid seams\n\n\t\t\t\t\t// two texels less per square (one texel will do for NEAREST)\n\t\t\t\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n\t\t\t\t\t// Unwrap\n\n\t\t\t\t\t// space: -1 ... 1 range for each square\n\t\t\t\t\t//\n\t\t\t\t\t// #X##\t\tdim    := ( 4 , 2 )\n\t\t\t\t\t//  # #\t\tcenter := ( 1 , 1 )\n\n\t\t\t\t\tvec2 planar = v.xy;\n\n\t\t\t\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\t\t\t\tfloat almostOne = 1.0 - almostATexel;\n\n\t\t\t\t\tif ( absV.z >= almostOne ) {\n\n\t\t\t\t\t\tif ( v.z > 0.0 )\n\t\t\t\t\t\t\tplanar.x = 4.0 - v.x;\n\n\t\t\t\t\t} else if ( absV.x >= almostOne ) {\n\n\t\t\t\t\t\tfloat signX = sign( v.x );\n\t\t\t\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\n\t\t\t\t\t} else if ( absV.y >= almostOne ) {\n\n\t\t\t\t\t\tfloat signY = sign( v.y );\n\t\t\t\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\t\t\t\tplanar.y = v.z * signY - 2.0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Transform to UV space\n\n\t\t\t\t\t// scale := 0.5 / dim\n\t\t\t\t\t// translate := ( center + 0.5 ) / dim\n\t\t\t\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n\t\t\t\t}\n\n\t\t\t\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n\t\t\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n\t\t\t\t\t// for point lights, the uniform @vShadowCoord is re-purposed to hold\n\t\t\t\t\t// the distance from the light to the world-space position of the fragment.\n\t\t\t\t\tvec3 lightToPosition = shadowCoord.xyz;\n\n\t\t\t\t\t// bd3D = base direction 3D\n\t\t\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\t\t\t// dp = distance from light to fragment position\n\t\t\t\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\n\t\t\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t\t\t\t#else // no percentage-closer filtering\n\n\t\t\t\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\n\t\t\t\t\t#endif\n\n\t\t\t\t}\n\n\t\t\t#endif\n\t\t\t// shadowmask pars fragment\n\n\t\t\tfloat getShadowMask() {\n\n\t\t\t\tfloat shadow = 1.0;\n\n\t\t\t\t#ifdef USE_SHADOWMAP\n\n\t\t\t\t#if NUM_DIR_LIGHTS > 0\n\n\t\t\t\tDirectionalLight directionalLight;\n\n\t\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\t\t\t\tdirectionalLight = directionalLights[ i ];\n\t\t\t\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t\t#if NUM_SPOT_LIGHTS > 0\n\n\t\t\t\tSpotLight spotLight;\n\n\t\t\t\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\t\t\t\tspotLight = spotLights[ i ];\n\t\t\t\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\n\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t\t#if NUM_POINT_LIGHTS > 0\n\n\t\t\t\tPointLight pointLight;\n\n\t\t\t\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\t\t\t\tpointLight = pointLights[ i ];\n\t\t\t\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\n\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\treturn shadow;\n\n\t\t\t}\n\n\t\t\t// main\n\t\t\tvoid main() {\n\n\t\t\t\tvec4 texel1 = texture2D( tDiffuse1, vUv ); //frame i\n\t\t\t\tvec4 texel2 = texture2D( tDiffuse2, vUv ); // frame i + 1\n\t\t\t\tvec4 texel3 = texture2D( tDiffuse3, vUv ); // static texture (background)\n\t\t\t\ttexel1.xyz = pow( texel1.xyz, vec3( 1.7 ) ); // gamma correction\n\t\t\t\ttexel2.xyz = pow( texel2.xyz, vec3( 1.7 ) ); // gamma correction\n\t\t\t\tfloat m = 1.0;\n\t\t\t    float m1 = smoothstep( 0.18, 0.22, vUv.y ); // 0 --- 0.25 = 0, 0.25 --- 0.3 = mix, 0.3 --- 1 = 1.0\n\t\t\t    float m2 = 1.0 - smoothstep( 0.75, 0.82, vUv.y );\n\t\t\t    m = m1 * m2;\n\t\t\t\tvec4 dynamic = mix( texel1, texel2, mixRatio );\n\n\t\t\t\t// light\n\t\t\t\tvec4 sumLights = vec4( 0.1, 0.1, 0.1, 1.0 );\n\n\t\t\t\tfor( int i = 0; i < NUM_POINT_LIGHTS; i++ ) {\n\t\t\t\t\tvec3 lightDirection = normalize( pointLights[i].position - vPos );\n\n\t\t\t\t\tsumLights.rgb += vec3( max(0.0, dot( vNormal, lightDirection ) ) ) * pointLights[i].color ;\n\t\t\t\t}\n\n\t\t\t\tsumLights.rgb += ambientLightColor;\n\n\t\t\t\tsumLights *= ( getShadowMask() );\n\n\t\t\t\tgl_FragColor =  sumLights * ( opacity * mix( texel3, dynamic, staticRatio * m ) ) ;\n\n\t\t\t}\n"}});